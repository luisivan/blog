---
title: Solving the biggest bug in programming
date: "2016-12-18"
template: "post"
draft: false
slug: "/solving-the-biggest-bug-in-programming-471dfbb411f0"
category: "Programming"
description: ""
---

I’m living my 10th year as a programmer. I started just creating free software projects because school was boring, but in the course of these previous years, I have created software used by people, both in the consumer and enterprise environments.

There are a few universal truths about programming, but there’s one that fascinates me the most: No matter how skilled you are, how many people work on it, or how much money you spend on it, **software will always be buggy**.

When I was working on toy projects that only my parents used (they were my most avid early adopters!) it was OK for them to have bugs. I had a great bug reporting session during dinner, and the bugs didn’t produce losses or got people hurt.

I think the other extreme may be companies such as SpaceX — **a bug in their software could cost them multiple billions of dollars**.

And I’m sure they have amazing programmers, and having geniuses onboard obviously helps to mitigate the risk of a bug appearing while landing a rocket on Mars.

But putting a team of genius hackers working on something doesn’t guarantee the software will be rock-solid. Instead, if you think about it, sometimes the more skilled the hackers are the more opinionated.

Which drives us to one of **the most important bottlenecks of software development — working with other people’s code** — basically, reading other people’s mind.

Our brains are very unique, and the world’s variety is a great proof of that. And code is just an output, created by a brain, which has tons of opinions and views.

But code can be sometimes seen as art — I certainly see code as a very special kind of art — and art is the most opinionated thing ever.

Sometimes people just reimplement software because they know it’ll be more cost effective to do so than to wrap their head around the output of random people’s brains.

Because, in the end, programming languages are just languages. The machine interprets them in a mathematical way, but for a human, they can be interpreted in multiple ways.

However, **there’s a universal language everybody in the world can understand, and it’s spatial visualization**. Just think about how you would ask for the bill in a restaurant in a country in which they speak a language you don’t. Everybody understands that weird hand gesture.

So one day I was shown one of the most enlightening things I have experienced: how **spatial visualization will forever change programming — by using VR**.

I put on the headset, I handled the trackers, and **suddenly I was in a Tron-like world walking by the RSA algorithm** — and I mean, I was literally walking by it. I could see the calls from one function to the other. I could see the call stack. I could even see what operations the code was doing. And I could open a virtual display with the actual code of that function on it, and edit it in real time.

I felt I didn’t want to code in 2D again. I wanted to immerse myself, understand the code and make it better.

A visionary founder I met last summer in San Mateo, John Voorhees, had a revelation: from here to a few years, **we all will be able to understand code to a new dimension**, debug it literally seeing how functions are calling each other, have infinite virtual displays, and the easiest way to interact with version control. So he went to found [Primitive](http://primitive.io/).

Because I totally follow that vision and want it to become a reality, **I’m joining [Primitive](http://primitive.io/)’s Advisory Board**. I’m delighted to be part of what will be the future of software development.

I’m extremely optimistic about fixing the most important bug of programming by understanding code in a universal, canonical way.

*Primitive is [hiring a software engineer](https://angel.co/prime-software-systems/jobs/181138-software-engineer), check it out if you want to be part of building the future of software development.*
